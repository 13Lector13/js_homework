'number' + 3 + 3
/*
+ - это левоассоциативный оператор, поэтому
'number' + 3 === 'number3'
'number3' +3 === 'number33'
*/

null + 3
/*
null - это пустое значение(0), поэтому 
null + 3 === 3
*/

5 && "qwerty"
/*
&& находит первое ложное значение, но если все операнды были истинными, возвращается последний, поэтому
5 && 'qwerty' вернет 'qwerty'
*/

+'40' + +'2' + "hillel";
/*
+, стоящий перед типом данных, преобразует их в Number
+'40' === 40
+'2' === 2
+ - это левоассоциативный оператор, поэтому
40 + 2 === 42
42 + 'hillel' === '42hillel'
*/

'10' - 5 === 6;
/*
В операциях с цифрами, строки, в которых записано чисельное значение, а не буквенное, будут преобразованы в числа, поэтому
'10' - 5 === 5
=== знак строгой равности (значение и тип данных должны быть идентичны)
 5 === 6 выдаст false, потому что 5 не равно 6
*/

true + false
/*
значение true == 1, а значение false == 0, поэтому
true + false === 1
*/

'4px' - 3
/*
От строки, в которой есть буквенные символы, отнимаем числовое значение. Бессмысленная операция
Будет ответ Nan
*/

'4' - 3
/*
В операциях с цифрами, строки, в которых записано чисельное значение, а не буквенное, будут преобразованы в числа, поэтому
'4' - 3 === 1
*/

'6' + 3 ** 0;
/*
** - правоассоциативный оператор, поэтому возведение в степень будет выполняться первым
3 ** 0 === 1
'6' + 1 === '61'
*/

12 / '6'
/*
В операциях с цифрами, строки, в которых записано чисельное значение, а не буквенное, будут преобразованы в числа, поэтому
12 / '6' === 2
*/

'10' + (5 === 6);
/*
5 не равно 6, поэтому (5 === 6) будет false
Поскольку '10' является строкой, то преобразования false к числовому значению 0 не будет
'10' + false === '10false'
*/

null == ''
/*
Null и '' приравниваются к falsy значениям, но
null == undefined выдаст true (null === undefined дает false). Как я понимаю, null можно нестрого сравнивать только с undefined
и только в этом случае будет true. Во всех остальных случаях - false (даже null == null выдаст false)
null == '' выдаст false
*/

3 ** (9 / 3);
/*
Первое действие выполняется в скобках
9 / 3 === 3
3 ** 3 === 3 * 3 * 3
3 * 3 * 3 === 27
*/

!!'false' == !!'true'
/*

*/

0 || '0' && 1
/*
Вычесление идет слева направо, но приоритет у && больше, чем у ||
&& находит первое ложное значение, но если все операнды были истинными, возвращается последний
Число, объект, массив или строка являются истиной, поэтому
'0' && 1 выдаст 1
|| возвращает первое истинное, поэтому
0 || 1 выдаст 1
*/

(+null == false) < 1;
/*
+, стоящий перед типом данных, преобразует их в Number
+null == 0
false == 0
+null == false выдаст true
true == 1
true < 1 выдаст false
*/

false && true || true
/*
Вычесление идет слева направо, но и приоритет у && больше, чем у ||
Оператор && возвращает первое ложное значение, а || –  первое истинное, поэтому
false && true выдаст false, 
false || true выдаст true
*/

false && (false || true);
/*
Вычесление идет слева направо, но сначало операция в скобках:
(false || true) выдаст true
false && true выдаст false
*/

(+null == false) < 1 ** 5;
/*
+, стоящий перед типом данных, преобразует их в Number
+null == 0
false == 0
+null == false выдаст true
true == 1
1 ** 5 === 1
true < 1 выдаст false
*/